  Author: Thomas Schoebel-Theuer
  Copyright: University of Stuttgart
  License: see files SOFTWARE-LICENSE, PATENT-LICENSE

context pconf !klinux

brick #spy_trace_old
purpose trace all operations and their parameters/results to a logfile
desc
  Simple provisionary implementation.
  Use for debugging / regression testing.
enddesc

static_data {
#include <stdio.h>
}

data {
  FILE * file;
  bool do_phys;
}

input :<in(:2:)

input :<hook

output :>out(:2:)

operation $output_init
{
  if(@destr) {
    fclose(@#file);
    @success = TRUE;
  }
  if(@constr) {
    @#do_phys= FALSE;
    if(*@param == '+') {
      @param++;
      @#do_phys = TRUE;
    }
    @#file = fopen(@param, "w");
    @success = @#file != NULL;
  }
}

@.func basic(char * op_name, int sect_nr)
{
  fprintf(@#file, "op_%s(:%d:) '%s'  %llx:%llx ", op_name, sect_nr, @param, @log_addr, @log_len);
}

@.func res()
{
  fprintf(@#file, "\tsuccess=%d ", @success);
}

@.func flush()
{
  fprintf(@#file, "\n");
  fflush(@#file);
}

@.macro all_ops(sect_nr)
{

section (:sect_nr:)

operation $transfer
{
  basic("transfer", sect_nr);
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx ", @phys_addr);
  fprintf(@#file, "direction=%d prio=%d", @direction, @prio);
  flush();
  @=call :<in$transfer @args;
  res();
  if(@#do_phys)
  fprintf(@#file, "phys_len=%lx", @phys_len);
  flush();
}

operation $wait
{
  basic("wait", sect_nr);
  fprintf(@#file, "prio=%d action=%d", @prio, @action);
  flush();
  @=call :<in$wait @args;
  res();
  flush();
}

operation $get
{
  basic("get", sect_nr);
  fprintf(@#file, "forwrite=%d", @forwrite);
  flush();
  @=call :<in$get @args;
  res();
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx phys_len=%lx ", @phys_addr, @phys_len);
  fprintf(@#file, "version=%d", @version);
  flush();
}

operation $put
{
  basic("put", sect_nr);
  fprintf(@#file, "prio=%d", @prio);
  flush();
  @=call :<in$put @args;
  res();
  flush();
}

operation $lock
{
  basic("lock", sect_nr);
  fprintf(@#file, "data_lock=%d addr_lock=%d try_addr=%llx try_len=%llx action=%d", @data_lock, @addr_lock, @try_addr, @try_len, @action);
  flush();
  @=call :<in$lock @args;
  res();
  fprintf(@#file, "try_addr=%llx try_len=%llx", @try_addr, @try_len);
  flush();
}

operation $unlock
{
  basic("unlock", sect_nr);
  fprintf(@#file, "try_addr=%llx try_len=%llx", @try_addr, @try_len);
  flush();
  @=call :<in$unlock @args;
  res();
  fprintf(@#file, "try_addr=%llx try_len=%llx", @try_addr, @try_len);
  flush();
}

operation $getaddr
{
  fprintf(@#file, "op_getaddr(:%d:) '%s' log_len=%llx where=%d exclu=%d action=%d try_len=%llx", sect_nr, @param, @log_len, @where, @exclu, @action, @try_len);
  flush();
  @=call :<in$getaddr @args;
  res();
  fprintf(@#file, "log_addr=%llx log_len=%llx", @log_addr, @log_len);
  flush();
}

operation $create
{
  basic("clear", sect_nr);
  fprintf(@#file, "clear=%d melt=%d", @clear, @melt);
  flush();
  @=call :<in$create @args;
  res();
  flush();
}

operation $delete
{
  basic("delete", sect_nr);
  flush();
  @=call :<in$delete @args;
  res();
  flush();
}

operation $move
{
  basic("move", sect_nr);
  fprintf(@#file, "offset=%llx offset_max=%llx", @offset, @offset_max);
  flush();
  @=call :<in$move @args;
  res();
  fprintf(@#file, "offset=%llx", @offset);
  flush();
}

operation $tr
{
  basic("tr", sect_nr);
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx ", @phys_addr);
  fprintf(@#file, "direction=%d prio=%d", @direction, @prio);
  flush();
  @=call :<in$tr @args;
  res();
  if(@#do_phys)
  fprintf(@#file, "phys_len=%lx", @phys_len);
  flush();
}

operation $gettr
{
  basic("gettr", sect_nr);
  fprintf(@#file, "forwrite=%d prio=%d", @forwrite, @prio);
  flush();
  @=call :<in$gettr @args;
  res();
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx phys_len=%lx", @phys_addr, @phys_len);
  flush();
}

operation $trput
{
  basic("trput", sect_nr);
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx ", @phys_addr);
  fprintf(@#file, "prio=%d", @prio);
  flush();
  @=call :<in$trput @args;
  res();
  flush();
}

operation $putwait
{
  basic("putwait", sect_nr);
  fprintf(@#file, "prio=%d", @prio);
  flush();
  @=call :<in$trput @args;
  res();
  flush();
}

operation $createget
{
  basic("createget", sect_nr);
  fprintf(@#file, "clear=%d melt=%d", @clear, @melt);
  flush();
  @=call :<in$createget @args;
  res();
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx phys_len=%lx", @phys_addr, @phys_len);
  flush();
}

operation $getaddrcreateget
{
  fprintf(@#file, "op_getaddrcreateget(:%d:) '%s' log_len=%llx exclu=%d action=%d clear=%d melt=%d try_len=%llx", sect_nr, @param, @log_len, @exclu, @action, @clear, @melt, @try_len);
  flush();
  @=call :<in$getaddrcreateget @args;
  res();
  fprintf(@#file, "log_addr=%llx log_len=%llx ", @log_addr, @log_len);
  if(@#do_phys)
  fprintf(@#file, "phys_addr=%lx phys_len=%lx", @phys_addr, @phys_len);
  flush();
}

operation $putdelete
{
  basic("putdeleteputaddr", sect_nr);
  flush();
  @=call :<in$putdelete @args;
  res();
  flush();
}

}

//@.expand all_ops(0)
//@.expand all_ops(1)
all_ops(0)
all_ops(1)
