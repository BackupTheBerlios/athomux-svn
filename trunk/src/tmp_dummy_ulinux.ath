Author: Roland Niese
Copyright: Roland Niese
License: see files SOFTWARE-LICENSE, PATENT-LICENSE

context: pconf *
context: cconf *

brick #tmp_dummy_ulinux

purpose Provide a status nest

desc
	Provides a simple output nest.
	Memory can be created and deleted at arbitrary addresses, but not moved.
	No overlapping creates allowed.
	Creates and deletes must occur pairwise.
enddesc


static_data {
	#include <stdlib.h>
}


data {
	struct mem_block {
		struct mem_block *next, *last;
		addr_t log_addr;
		len_t log_len;
		char data[0];
	} *block_list;
}


operation $brick_init {
	INIT_ALL_INPUTS ();
	INIT_ALL_INSTANCES ();
	INIT_ALL_OUTPUTS ();
}


output :>out

	operation $output_init {
		trace ("#tmp_dummy:>out$output_init (destr=%d, constr=%d) called\n", @destr, @constr);
		if (@destr) {
			struct mem_block *iter = @#.block_list;
			while (iter) {
				struct mem_block *next = iter->next;
				free(iter);
				iter = next;
			}
			@#.block_list = NULL;
		}
		if (@constr) {
			@#.block_list = NULL;
		}		
		@success = TRUE;
	}

	operation $create {
		struct mem_block *iter, *prev;
		for (prev = NULL, iter = @#.block_list; iter && iter->log_addr < @log_addr + @log_len; prev = iter, iter = iter->next) {
			@.check (iter->log_addr + iter->log_len > @log_addr, "Tried to $create [%llX..%llX], but [%llX..%llX] already existed!", @log_addr, @log_addr + @log_len, iter->log_addr, iter->log_addr + iter->log_len);
		}
		struct mem_block *new_block = malloc(sizeof *new_block + (size_t)@log_len);
		@.check (!new_block, "Out of memory!");
		if (@clear) {
			memset(new_block->data, 0, (size_t)@log_len);
		}
		new_block->next = iter;
		new_block->last = prev;
		new_block->log_addr = @log_addr;
		new_block->log_len = @log_len;
		if (iter) {
			iter->last = new_block;
		}
		if (prev) {
			prev->next = new_block;
		}
		else {
			@#.block_list = new_block;
		}
		trace ("Created a new block of memory at [0x%llX..0x%llX]\n", @log_addr, @log_addr + @log_len);
		@success = TRUE;
	}
	
	operation $delete {
		struct mem_block *iter, *prev;
		for (prev = NULL, iter = @#.block_list; iter && iter->log_addr < @log_addr + @log_len; prev = iter, iter = iter->next) {
			if (iter->log_addr + iter->log_len >= @log_addr) {
				if (iter->log_addr == @log_addr && iter->log_len == @log_len) {
					if (iter->last) {
						iter->last->next = iter->next;
					}
					else {
						@#.block_list = iter->next;
					}
					if (iter->next) {
						iter->next->last = iter->last;
					}
					free(iter);
					@success = TRUE;
					trace ("Deleted a block of memory at [0x%llX..0x%llX]\n", @log_addr, @log_addr + @log_len);
					return;
				}
				@.err ("Could not delete [0x%llX..0x%llX] because it did not match with found block [0x%llX..0x%llX]!", @log_addr, @log_addr + @log_len, iter->log_addr, iter->log_addr + iter->log_len);
			}
		}
		// deleting a hole has no effect, but is ok.
		@.msg ("WARNING", "Deleting a hole at [0x%llX..0x%llX] (ok)", @log_addr, @log_addr + @log_len);
		@success = TRUE;
	}
	
	operation $get,$gettranswait {
		struct mem_block *iter;
		for (iter = @#.block_list; iter && iter->log_addr < @log_addr + @log_len; iter = iter->next) {
			if (@log_addr >= iter->log_addr) {
				len_t cut_len = @log_len;
				if (@log_addr + @log_len > iter->log_addr + iter->log_len) {
					cut_len = iter->log_addr + iter->log_len - @log_addr;
					@.msg ("WARNING", "Could not get all memory (0x%llX bytes) at 0x%llX, cut to 0x%llX bytes!", @log_len, @log_addr, cut_len);
				}
				@phys_addr = MAKE_PADDR (iter->data) + (plen_t)(@log_addr - iter->log_addr);
				@phys_len = (plen_t)cut_len;
				@success = TRUE;
				return;
			}
		}
		@.err ("Could not get memory out of a hole!");
	}
	
	operation $trans,$transwait {
		struct mem_block *iter;
		addr_t log_addr = @log_addr;
		addr_t log_len = @log_len;
		paddr_t phys_addr = @phys_addr;
		iter = @#.block_list;
		while (iter && iter->log_addr + iter->log_len <= log_addr) {
			iter = iter->next;
		}
		@.check (!iter, "Could not transfer into a hole at 0x%llX!", @log_addr);
		if (iter->log_addr < log_addr) {
			len_t delta = log_addr - iter->log_addr;
			len_t cut_len = log_len;
			if (log_addr + log_len > iter->log_addr + iter->log_len) {
				cut_len = iter->log_addr + iter->log_len - (log_addr + log_len);
			}
			if (@direction == direct_read) {
				memmove(MAKE_PTR (phys_addr), iter->data + (size_t)delta, (size_t)cut_len);
			}
			else {
				memmove(iter->data + (size_t)delta, MAKE_PTR (phys_addr), (size_t)cut_len);
			}
			log_len -= cut_len;
			log_addr += cut_len;
			phys_addr += (plen_t)cut_len;
			iter = iter->next;
		}
		while (iter && iter->log_addr == log_addr) {
			len_t cut_len = log_len;
			if (log_len > iter->log_len) {
				cut_len = iter->log_len;
			}
			if (@direction == direct_read) {
				memmove(MAKE_PTR (phys_addr), iter->data, (size_t)cut_len);
			}
			else {
				memmove(iter->data, MAKE_PTR (phys_addr), (size_t)cut_len);
			}
			log_len -= cut_len;
			log_addr += cut_len;
			phys_addr += (plen_t)cut_len;			
			iter = iter->next;
		}
		if (log_len > 0) {
			@.msg ("WARNING: ", "Could not transfer all data to [0x%llX..0x%llX] due to a gap at 0x%llX!", @log_addr, @log_addr + @log_len, @log_addr + @log_len - log_len);
		}
		@success = TRUE;
	}
	
	operation $put,$wait,$putwait {
		@success = TRUE;
	}

	operation $move,$gadr,$padr,$lock,$unlock {
		@.err ("Operation not supported!");
	}
