Author: Hardy Kahl
Copyright: Hardy Kahl
License: see files SOFTWARE-LICENSE, PATENT-LICENSE

context pconf: !klinux
context cconf: !klinux

brick #ppipe

purpose pipe for physical streams

desc
  - implements multi user capabilities.
  - with BUFSIZE the size of the pipe buffer is set.
    FIXME: allow dynamic buffer size given in @param at $init...

          +---------+
          |         |
    mem --+--     --+-- pstrmr
          |         |
  ilock --+--     --+-- pstrmw
          |         |
   stat --+--       |
          |         |
          +---------+

enddesc

example
endexample




static_data {
  #define MIN(a,b) ((a)<(b)?(a):(b))
  #define MAX(a,b) ((a)>(b)?(a):(b))

  #define BUFSIZE                (1024*40)

  #define LOCK_ADDR_MOD          0
  #define LOCK_ADDR_READER_WAIT  1
  #define LOCK_ADDR_WRITER_WAIT  2

  #define LOCK_MAND_READER       1
  #define LOCK_MAND_WRITER       2

  #define LOCK_MAND_WAIT1        1
  #define LOCK_MAND_WAIT2        2

  struct status_t {
    addr_t buf_start;
    addr_t buf_len;
    offs_t avail_start;
    len_t avail_len;
  };
}




// FIXME: use $brick_init !!!
operation $brick_init
{
  char const *param_orig=@param;
  @param="WA";
  INIT_ALL_INPUTS();
  INIT_ALL_INSTANCES();
  INIT_ALL_OUTPUTS();
  @param=param_orig;
}
output :>init
operation $output_init
{
  if (strcmp(@param,"WA")==0) { @success=TRUE; return; } // FIXME: workaround, init later

  success_t succ;

  if (@destr && @constr) {
    // flush state
    PC_FLUSH(PPIPE_STAT);
  }
  else if (@destr) {
    // deinstantiate brick
    struct status_t *status = PC_GET_DIRTY(PPIPE_STAT, 0, sizeof(struct status_t));
    @.check(status==NULL, "cannot get pointer on status information");

    @=call :<mem$delete [@mandate] (status->buf_start, status->buf_len) => (succ);
    @.check(succ!=TRUE, "delete failed");
  }
  else if (@constr) {
    // instantiate brick

    struct status_t *status = PC_GET_DIRTY(PPIPE_STAT, 0, sizeof(struct status_t));

    if (status==NULL) {
      // no status available in input nest. creating new one...
      success_t succ;

      @=call :<stat$create [@mandate] (0, sizeof(struct status_t)) => (succ);
      @.check(succ!=TRUE, "cannot allocate memory for status information");

      status = PC_GET_DIRTY(PPIPE_STAT, 0, sizeof(struct status_t));
      @.check(status==NULL, "FIXME: switch to error state - cannot get pointer on status information");

      // initializing status
      @=call :<mem$gadrcreate [@mandate] (BUFSIZE) => (succ, status->buf_start, status->buf_len);
      @.check(succ!=TRUE, "gadrcreate failed");
    
      status->avail_start = 0;
      status->avail_len = 0;
    }
  }

  @success = TRUE;
}




output :>pstrmr




operation $trans
{
  struct status_t *status = PC_GET_DIRTY(PPIPE_STAT, 0, sizeof(struct status_t));
  @.check(status==NULL, "cannot get pointer on status information");

  @.check(@direction!=direct_read, "cannot write in unidirectional readable stream");

  success_t succ;
  
  // @mandate should be unique for every thread
  @=call :<ilock$lock [@mandate] (LOCK_ADDR_MOD, 1, lock_write) => (succ);
  @.check(succ!=TRUE, "cannot get lock");

  len_t block_avail = MIN(status->buf_len - status->avail_start, status->avail_len);

  while (block_avail==0) {
    // wait for more data
    @=call :<ilock$lock [LOCK_MAND_WAIT1] (LOCK_ADDR_READER_WAIT, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot get lock - FIXME: error state or release other locks");
    if (succ!=TRUE) {
      // release modify lock
      @=call :<ilock$unlock [@mandate] (LOCK_ADDR_MOD, 1) => (succ);
      @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
      @.err("cannot get lock");
    }
      
    // release modify lock to prevent blocking the writer
    @=call :<ilock$unlock [@mandate] (LOCK_ADDR_MOD, 1) => (succ);
    @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");

    @=call :<ilock$lock [LOCK_MAND_WAIT2] (LOCK_ADDR_READER_WAIT, 1, lock_write) => (succ);
    if (succ!=TRUE) {
      // release wait lock
      @=call :<ilock$unlock [LOCK_MAND_WAIT1] (LOCK_ADDR_READER_WAIT, 1, lock_write) => (succ);
      @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
      @.err("cannot get lock");
    }
      
    // new data is now available
    // release wait lock and get modify lock
      
    @=call :<ilock$unlock [LOCK_MAND_WAIT2] (LOCK_ADDR_READER_WAIT, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
      
    @=call :<ilock$lock [@mandate] (LOCK_ADDR_MOD, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot get lock");
      
    block_avail = MIN(status->buf_len - status->avail_start, status->avail_len);
  }

  // do the transfer
  addr_t taddr = @log_addr;
  len_t tlen = @log_len;
  @log_addr = status->buf_start + status->avail_start;
  @log_len = MIN(block_avail, @log_len);
  @=call :<mem$trans [@mandate] (@args);
  @log_addr = taddr;
  @log_len = tlen;
  if (@success==TRUE) {
    // update pointers
    status->avail_start = (status->avail_start + @phys_len) % status->buf_len;
    status->avail_len -= @phys_len;

    // wakeup writer
    @=call :<ilock$unlock [LOCK_MAND_WAIT1] (LOCK_ADDR_WRITER_WAIT, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
  }

  // release lock
  @=call :<ilock$unlock [@mandate] (LOCK_ADDR_MOD, 1) => (succ);
  @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
}




operation $wait
{
  @=call :<mem$wait [@mandate] (@args);
}




output :>pstrmw




operation $trans
{
  struct status_t *status = PC_GET_DIRTY(PPIPE_STAT, 0, sizeof(struct status_t));
  @.check(status==NULL, "cannot get pointer on status information");

  @.check(@direction!=direct_write, "cannot read in unidirectional writable stream");

  success_t succ;

  // @mandate should be unique for every thread
  @=call :<ilock$lock [@mandate] (LOCK_ADDR_MOD, 1, lock_write) => (succ);
  @.check(succ!=TRUE, "cannot get lock");
  
  offs_t writer_start = (status->avail_start + status->avail_len) % status->buf_len;
  len_t block_avail = MIN(status->buf_len - writer_start, status->buf_len - status->avail_len);

  while (block_avail==0) {
    @=call :<ilock$lock [LOCK_MAND_WAIT1] (LOCK_ADDR_WRITER_WAIT, 1, lock_write) => (succ);
    if (succ!=TRUE) {
      // release modify lock
      @=call :<ilock$unlock [@mandate] (LOCK_ADDR_MOD, 1) => (succ);
      @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
      @.err("cannot get lock");
    }
      
    // release modify lock to prevent blocking the reader
    @=call :<ilock$unlock [@mandate] (LOCK_ADDR_MOD, 1) => (succ);
    @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
      
    @=call :<ilock$lock [LOCK_MAND_WAIT2] (LOCK_ADDR_WRITER_WAIT, 1, lock_write) => (succ);
    if (succ!=TRUE) {
      // release wait lock
      @=call :<ilock$unlock [LOCK_MAND_WAIT1] (LOCK_ADDR_WRITER_WAIT, 1, lock_write) => (succ);
      @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
      @.err("cannot get lock");
    }
      
    // new free memory is now available
    // release wait lock and get modify lock
      
    @=call :<ilock$unlock [LOCK_MAND_WAIT2] (LOCK_ADDR_WRITER_WAIT, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
    
    @=call :<ilock$lock [@mandate] (LOCK_ADDR_MOD, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot get lock");
      
    writer_start = (status->avail_start + status->avail_len) % status->buf_len;
    block_avail = MIN(status->buf_len - writer_start, status->buf_len - status->avail_len);
  }

  // now do the transfer
  addr_t taddr = @log_addr;
  len_t tlen = @log_len;
  @log_addr =  status->buf_start + writer_start;
  @log_len = MIN(block_avail, @log_len);
  @=call :<mem$trans [@mandate] (@args);
  @log_addr = taddr;
  @log_len = tlen;
  if (@success==TRUE) {
    // update pointers
    status->avail_len += @phys_len;

    // wakeup reader
    @=call :<ilock$unlock [LOCK_MAND_WAIT1] (LOCK_ADDR_READER_WAIT, 1, lock_write) => (succ);
    @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");
  }

  // release lock
  @=call :<ilock$unlock [@mandate] (LOCK_ADDR_MOD, 1) => (succ);
  @.check(succ!=TRUE, "cannot release lock - FIXME: switch to error state");

  @success = TRUE;
}




operation $wait
{
  @=call :<mem$wait [@mandate] (@args);
}




input :<mem
input :<ilock




input :<stat
use PC PPIPE_STAT [1];
