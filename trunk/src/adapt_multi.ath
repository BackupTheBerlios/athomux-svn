Author: Hardy Kahl
Author: Roland Niese (modified to use lock_mutex instead of lock_ulinux)
Copyright: Hardy Kahl
License: see files SOFTWARE-LICENSE, PATENT-LICENSE

context: pconf *
context: cconf *

brick #adapt_multi

purpose Allows multiple users on a single-user nest

desc
	Outputs not capable of handling multiple simultaneous operation calls can use this adapter to make it a monitor.
	Input and output calls are locked separately, so at most one input and one output call can pass this brick at the same time.
	Modification by nieserd Dez 2005:
	Brick used #lock_ulinux to implement mutual exclusion, what failed when two incoming
	simultaneous operation calls used the same mandate (#lock_ulinux is mandate-oriented).
	#lock_mutex_ulinux ignores mandates, so this won't happen anymore.
	Internally uses a #tmp_dummy_ulinux brick for lock_mutex' state. For compatibility with
	programs using the brick, no additional input is added.
	
	Note:
		Bricks should try to implement concurrency safety in a more flexible way, e.g.
		called operations could lock only the ranges of the status nest they actually access.
enddesc

instance #tmp_dummy_ulinux as tmp;
wire :>out as ##lock:<tmp;
instance #lock_mutex as lock;


operation $brick_init {
	if (@destr) {
		INIT_ALL_OUTPUTS ();
		//INIT_ALL_INSTANCES ();
		INIT_ONE_INSTANCE (lock, "");
		INIT_ONE_INSTANCE (tmp, "");
		INIT_ALL_INPUTS ();
	}
	if (@constr) {
		INIT_ALL_INPUTS ();
		//INIT_ALL_INSTANCES ();
		INIT_ONE_INSTANCE (tmp, "");
		INIT_ONE_INSTANCE (lock, "");
		INIT_ALL_OUTPUTS ();
	}
}


input :<in

operation $op
{
  success_t succ;
  // get lock
  @=call ##lock:>out$lock (1, 1, lock_write, lock_write) => (succ);
  @.check (!succ, "FIXME: Could not grab lock, switch to error state!");

  @=inputcall :>out$op [@mandate] (@args);

  // release lock
  @=call ##lock:>out$unlock (1, 1) => (succ);
  @.check (!succ, "FIXME: Could not release lock, switch to error state!");
}


output :>out

operation $op
{
  success_t succ;

  // get lock
  @=call ##lock:>out$lock (0, 1, lock_write, lock_write) => (succ);
  @.check (!succ, "FIXME: Could not grab lock, switch to error state!");

  @=outputcall :<in$op (@args);
  
  // release lock
  @=call ##lock:>out$unlock [@mandate] (0, 1) => (succ);
  @.check (!succ, "FIXME: Could not release lock, switch to error state!");
}
